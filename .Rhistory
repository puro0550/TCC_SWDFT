theme(
axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(face = "bold", hjust = 0.5)
)
lista_boxplots[[uf]] <- p
}
return(lista_boxplots)
}
####-------------- funções para SALVAR dataviz --------------####
salva_grafico_singular_pdf <- function(grafico, nome_arquivo = "grafico.pdf",
pasta_saida = "graficos_pdf",
largura = 8, altura = 5, unidades = "in") {
# Cria a pasta de saída se não existir
if (!dir.exists(pasta_saida)) {
dir.create(pasta_saida, recursive = TRUE)
}
# Caminho completo para salvar
caminho_completo <- file.path(pasta_saida, nome_arquivo)
# Salvar o gráfico
ggsave(
filename = caminho_completo,
plot = grafico,
width = largura,
height = altura,
units = unidades,
device = "pdf"
)
message("✅ Gráfico salvo em: ", normalizePath(caminho_completo))
}
salva_grafico_lista_pdf <- function(lista_graficos, prefixo_nome = "grafico", pasta_saida = "graficos_pdf",
largura = 8, altura = 5, unidades = "in") {
# Cria a pasta de saída, se não existir
if (!fs::dir_exists(pasta_saida)) {
fs::dir_create(pasta_saida)
}
# Itera sobre os nomes e gráficos
nomes_graficos <- names(lista_graficos)
for (i in seq_along(lista_graficos)) {
grafico <- lista_graficos[[i]]
nome <- nomes_graficos[i]
# Nome de arquivo descritivo
nome_arquivo <- sprintf("%s_%s.pdf", prefixo_nome, nome)
caminho_completo <- fs::path(pasta_saida, nome_arquivo)
# Exporta o gráfico
ggsave(
filename = caminho_completo,
plot = grafico,
width = largura,
height = altura,
units = unidades,
device = "pdf"
)
}
message("✅ Gráficos salvos com sucesso em: ", fs::path_abs(pasta_saida))
}
salvar_tabelas_tex <- function(lista_tabelas, pasta_saida = "tabelas_tex") {
# Verifica e cria a pasta de saída, se necessário
if (!dir.exists(pasta_saida)) {
dir.create(pasta_saida, recursive = TRUE)
}
# Percorre cada tibble da lista
purrr::iwalk(lista_tabelas, function(tabela, estado) {
nome_arquivo <- file.path(pasta_saida, paste0("tabela_", estado, ".tex"))
tabela %>%
kableExtra::kbl(format = "latex", booktabs = TRUE,
caption = paste("Análise horária de dados de radiação -", estado)) %>%
kableExtra::save_kable(nome_arquivo)
message("Tabela salva: ", nome_arquivo)
})
}
####-------------- função para REMOVER OUTLIERS --------------####
limpar_radiacao_flags <- function(dados) {
# Contagem de flags por tipo e estado (apenas outliers superiores)
resumo <- dados %>%
filter(flag_outlier == 1) %>%
count(estado, name = "sup_trocas") %>%
arrange(estado)
# Mensagens
cat("------------------------------\n")
cat("Outliers superiores:\n")
resumo %>%
pmap(~cat(paste0(..1, ": ", ..2, " trocas\n")))
cat("------------------------------\n")
# Substitui valores por NA
dados %>%
mutate(radiacao_kjm2 = if_else(flag_outlier == 1, NA_real_, radiacao_kjm2))
}
####-------------- função para RECONSTRUIR NA'S --------------####
# Flag para período diurno (com base no horário local)
criar_flag_diurno <- function(dados) {
dados %>%
mutate(
hora_utc_num = if (!"hora_utc_num" %in% names(.)) lubridate::hour(hora_utc) else hora_utc_num,
hora_local = case_when(
estado == "AM" ~ (hora_utc_num - 4) %% 24,
TRUE           ~ (hora_utc_num - 3) %% 24
),
flag_nascer_por = if_else(hora_local %in% c(6, 7, 18), 1, 0),
flag_dia = if_else(hora_local %in% 8:17, 1, 0)
)
}
zerar_radiacao_noturna <- function(dados) {
# Garante que as flags existem (evita erros caso chegue um df cru)
dados <- criar_flag_diurno(dados)
# “Noturno” = nem dia nem nascer/pôr
n_trocadas <- sum(dados$flag_dia == 0 & dados$flag_nascer_por == 0, na.rm = TRUE)
dados_editado <- dados %>%
mutate(
radiacao_kjm2 = if_else(flag_dia == 0 & flag_nascer_por == 0,
0,            # Zera só o realmente noturno
radiacao_kjm2)
)
cat("------------------------------\n")
cat("Valores noturnos substituídos por 0:", n_trocadas, "\n")
cat("------------------------------\n")
dados_editado
}
imputar_radiacao_bootstrap <- function(dados, seed = 123, verbose = FALSE) {
if (verbose) message("[INFO] Inicializando imputação de radiação com bootstrap...")
set.seed(seed)
## ------------------------------------------------------------------ ##
## 1. Paralelismo
## ------------------------------------------------------------------ ##
if (verbose) message("[INFO] Configurando paralelismo com futuros multisession...")
plan(multisession, workers = availableCores() - 1)
handlers(global = TRUE); handlers("progress")
inicio <- Sys.time()
if (verbose) message(paste0("[INFO] Início da execução: ", inicio))
## ------------------------------------------------------------------ ##
## 2. Flags (garantimos hora_local, flag_dia e flag_nascer_por)
## ------------------------------------------------------------------ ##
dados_proc <- dados %>%
{ if (!all(c("hora_local", "flag_dia", "flag_nascer_por") %in% names(.)))
criar_flag_diurno(.)
else .
} %>%
mutate(
ano      = lubridate::year(data_tempo),
mes_dia  = format(data_tempo, "%m-%d"),
grupo_id = paste(estado, mes_dia, hora_local, sep = "_")
)
if (verbose) message("[INFO] Colunas auxiliares 'ano', 'mes_dia' e 'grupo_id' criadas.")
## ------------------------------------------------------------------ ##
## 3. Conjunto de NAs a imputar  (dia normal OU nascer/pôr)
## ------------------------------------------------------------------ ##
na_imp <- dados_proc %>%
filter((flag_dia == 1 | flag_nascer_por == 1) & is.na(radiacao_kjm2)) %>%
select(grupo_id, ano, usar_q1 = flag_nascer_por)
if (verbose) message(paste0("[INFO] Encontrados ", nrow(na_imp), " valores NA elegíveis para imputação."))
## ------------------------------------------------------------------ ##
## 4. Histórico de valores válidos
## ------------------------------------------------------------------ ##
historico <- dados_proc %>%
filter((flag_dia == 1 | flag_nascer_por == 1) & !is.na(radiacao_kjm2)) %>%
group_by(grupo_id, ano) %>%
summarise(valor = first(radiacao_kjm2), .groups = "drop")
if (verbose) message("[INFO] Construído histórico de valores válidos por grupo e ano.")
## ------------------------------------------------------------------ ##
## 5. Função interna: bootstrap + estatística (mediana ou Q1)
## ------------------------------------------------------------------ ##
imputar_grupo <- function(grupo_id, ano_ref, usar_q1 = FALSE) {
amostras <- historico %>%
filter(grupo_id == grupo_id, ano != ano_ref) %>%
pull(valor)
n <- length(amostras)
if (n == 0) return(NA_real_)
if (n == 1) return(amostras[1])
n_boot <- if (n <= 12) 100 else 1000
boot_vals <- sample(amostras, size = n_boot, replace = TRUE)
if (usar_q1) {
return(as.numeric(stats::quantile(boot_vals, probs = 0.25, na.rm = TRUE)))
} else {
return(stats::median(boot_vals, na.rm = TRUE))
}
}
## ------------------------------------------------------------------ ##
## 6. Imputação paralela
## ------------------------------------------------------------------ ##
if (verbose) message("[INFO] Iniciando imputação paralela com barra de progresso...")
resultado <- with_progress({
p <- progressor(steps = nrow(na_imp))
future_mapply(
function(g, a, q1) { p(); imputar_grupo(g, a, usar_q1 = as.logical(q1)) },
na_imp$grupo_id,
na_imp$ano,
na_imp$usar_q1,
future.seed = seed,
future.packages = c("dplyr")
)
})
na_imp$radiacao_imputada <- resultado
if (verbose) message("[INFO] Imputações concluídas e atribuídas.")
## ------------------------------------------------------------------ ##
## 7. Mesclar resultados e limpar
## ------------------------------------------------------------------ ##
dados_final <- dados_proc %>%
left_join(na_imp, by = c("grupo_id", "ano")) %>%
mutate(
radiacao_kjm2 = dplyr::coalesce(radiacao_imputada, radiacao_kjm2),
reconstruido  = as.integer(!is.na(radiacao_imputada))
) %>%
select(-ano, -mes_dia, -grupo_id, -radiacao_imputada)
if (verbose) message("[INFO] Dados imputados integrados ao dataset final.")
## ------------------------------------------------------------------ ##
## 8. Encerramento
## ------------------------------------------------------------------ ##
fim   <- Sys.time()
tempo <- difftime(fim, inicio, units = "secs")
if (verbose) message(paste0("[INFO] Imputação concluída em ", round(as.numeric(tempo), 1),
" s (", round(as.numeric(tempo)/60, 1), " min)."))
plan(sequential)
if (verbose) message("[INFO] Plano de paralelismo resetado para sequencial.")
if (verbose) message("[SUCESSO] Função executada com sucesso. Retornando dados finais.")
return(dados_final)
}
# Função para salvar a parada
salvar_dados_rds <- function(dados,
arquivo = "dados_rad_reconstruidos.rds",
compress = "xz") {
if (!grepl("\\.rds$", arquivo, ignore.case = TRUE)) {
warning("O nome do arquivo não termina em '.rds'; estou adicionando automaticamente.")
arquivo <- paste0(arquivo, ".rds")
}
saveRDS(dados, file = arquivo, compress = compress)
message(sprintf("✅ Dados salvos em '%s' (compressão = '%s')", arquivo, compress))
invisible(arquivo)
}
boxplot_radiacao_estadual(rad_limpo)
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# Selecionando apenas as colunas interessantes
rad_limpo <- select(rad_limpo)
# Visualizando séries temporais de radiação
plots_teste <- plotar_series_todos_estados(rad_limpo, "2001-01-01", "ano", FALSE)
fft_teste <- fft_series_todos_estados(rad_limpo,"2001-01-01", periodo = "ano", primeiro_dia = FALSE, grafico = TRUE)
plots_teste$AM
fft_teste$AM$plot
plots_teste$BA
fft_teste$BA$plot
plots_teste$DF
fft_teste$DF$plot
plots_teste$RJ
fft_teste$RJ$plot
plots_teste$RS
fft_teste$RS$plot
fft_global <- fft_janelas_anuais_estados(rad_limpo, primeiro_dia = TRUE, ultimo_dia = TRUE, grafico = TRUE)
boxplot_radiacao_estadual(rad_limpo)
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# Selecionando apenas as colunas interessantes
rad_limpo <- select(rad_limpo)
# Visualizando séries temporais de radiação
plots_teste <- plotar_series_todos_estados(rad_limpo, "2001-01-01", "ano", FALSE)
fft_teste <- fft_series_todos_estados(rad_limpo,"2001-01-01", periodo = "ano", primeiro_dia = FALSE, grafico = TRUE)
plots_teste$AM
fft_teste$AM$plot
plots_teste$BA
fft_teste$BA$plot
plots_teste$DF
fft_teste$DF$plot
plots_teste$RJ
fft_teste$RJ$plot
plots_teste$RS
fft_teste$RS$plot
fft_global <- fft_janelas_anuais_estados(rad_limpo, primeiro_dia = FALSE, ultimo_dia = TRUE, grafico = TRUE)
fft_global$DF
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# Selecionando apenas as colunas interessantes
rad_limpo <- select(rad_limpo)
# Visualizando séries temporais de radiação
plots_teste <- plotar_series_todos_estados(rad_limpo, "2001-01-01", "ano", FALSE)
fft_teste <- fft_series_todos_estados(rad_limpo,"2001-01-01", periodo = "ano", primeiro_dia = FALSE, grafico = TRUE)
plots_teste$AM
fft_teste$AM$plot
plots_teste$BA
fft_teste$BA$plot
plots_teste$DF
fft_teste$DF$plot
plots_teste$RJ
fft_teste$RJ$plot
plots_teste$RS
fft_teste$RS$plot
fft_global <- fft_janelas_anuais_estados(rad_limpo,
primeiro_dia = FALSE,
ultimo_dia   = TRUE,
grafico      = TRUE)
# Vendo o que há para o Distrito Federal
fft_global$DF          # lista compacta: apenas plots + ids
names(fft_global$DF)   # nomes das janelas
# Recuperando um vetor de coeficientes (exemplo)
coef_env  <- attr(fft_global, "coef_store")
coef_vec  <- coef_env$`fft_DF_20030101`   # use o id exibido
str(coef_vec)
coef_env  <- attr(fft_global, "coef_store")
coef_vec  <- coef_env$"janela_1"   # use o id exibido
str(coef_vec)
coef_vec  <- coef_env$`janela_1`   # use o id exibido
str(coef_vec)
#----------- 1. Função que transforma UM resultado de FFT em tibble -----------
fft_to_tibble <- function(res_fft, overlap_lbl) {
coef_env <- attr(res_fft, "coef_store")
imap_dfr(res_fft,  # itera sobre estados
function(lista_janelas, estado) {
imap_dfr(lista_janelas,  # itera sobre janelas
function(janela, nome_janela) {
id <- janela$coef_id
if (is.na(id)) return(NULL)
coef <- coef_env[[id]]
n    <- length(coef)
half <- 1:(n %/% 2)
tibble(
estado    = estado,
janela    = nome_janela,
data_ini  = janela$intervalo[1],
overlap   = overlap_lbl,
freq_idx  = half - 1,
freq_rel  = (half - 1) / n,           # ciclos / hora
amp       = Mod(coef[half])
)
})
})
}
#----------- 2. Rodar todos os overlaps e empilhar ----------------------------
overlaps <- c(25, 30, 35, 40, 50, 60)
df_fft <- imap_dfr(
overlaps,
function(o, idx) {
message("Rodando overlap: ", o, "%")
res <- fft_janelas_anuais_estados(
dados            = rad_limpo,
primeiro_dia     = FALSE,
ultimo_dia       = TRUE,
overlap_percent  = o,
grafico          = FALSE
)
fft_to_tibble(res, overlap_lbl = o)
}
)
rlang::last_trace()
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Selecionando apenas as colunas interessantes
rad_limpo <- select(rad_limpo)
# Visualizando séries temporais de radiação
plots_teste <- plotar_series_todos_estados(rad_limpo, "2001-01-01", "ano", FALSE)
fft_teste <- fft_series_todos_estados(rad_limpo,"2001-01-01", periodo = "ano", primeiro_dia = FALSE, grafico = TRUE)
plots_teste$AM
fft_teste$AM$plot
plots_teste$BA
fft_teste$BA$plot
plots_teste$DF
fft_teste$DF$plot
plots_teste$RJ
fft_teste$RJ$plot
plots_teste$RS
fft_teste$RS$plot
fft_global <- fft_janelas_anuais_estados(rad_limpo,
primeiro_dia = FALSE,
ultimo_dia   = TRUE,
grafico      = TRUE)
rlang::last_trace()
rlang::last_trace(drop = FALSE)
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# Selecionando apenas as colunas interessantes
rad_limpo <- select(rad_limpo)
# Visualizando séries temporais de radiação
plots_teste <- plotar_series_todos_estados(rad_limpo, "2001-01-01", "ano", FALSE)
#
# fft_teste <- fft_series_todos_estados(rad_limpo,"2001-01-01", periodo = "ano", primeiro_dia = FALSE, grafico = TRUE)
# plots_teste$AM
# fft_teste$AM$plot
# plots_teste$BA
# fft_teste$BA$plot
# plots_teste$DF
# fft_teste$DF$plot
# plots_teste$RJ
# fft_teste$RJ$plot
# plots_teste$RS
# fft_teste$RS$plot
fft_global <- fft_janelas_anuais_estados(rad_limpo,
primeiro_dia = FALSE,
ultimo_dia   = TRUE,
grafico      = TRUE)
overlaps <- c(25, 30, 35, 40, 50, 60)
df_fft <- purrr::imap_dfr(
overlaps,
function(o, idx) {
base::message("Rodando overlap: ", o, "%")
res <- fft_janelas_anuais_estados(
dados            = rad_limpo,
primeiro_dia     = FALSE,
ultimo_dia       = TRUE,
overlap_percent  = o,
grafico          = FALSE
)
fft_to_tibble(res, overlap_lbl = o)
}
)
rlang::last_trace()
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# Selecionando apenas as colunas interessantes
rad_limpo <- select(rad_limpo)
# Visualizando séries temporais de radiação
plots_teste <- plotar_series_todos_estados(rad_limpo, "2001-01-01", "ano", FALSE)
#
# fft_teste <- fft_series_todos_estados(rad_limpo,"2001-01-01", periodo = "ano", primeiro_dia = FALSE, grafico = TRUE)
# plots_teste$AM
# fft_teste$AM$plot
# plots_teste$BA
# fft_teste$BA$plot
# plots_teste$DF
# fft_teste$DF$plot
# plots_teste$RJ
# fft_teste$RJ$plot
# plots_teste$RS
# fft_teste$RS$plot
resultado_fft <- fft_janelas_anuais_estados_v2(
dados = rad_limpo,
data_inicial = "2015-01-01",
data_final = "2022-12-31",
overlap_percent = 0.4,
grafico = FALSE
)
resultado_comp <- comparar_overlaps_fft(
dados = rad_limpo,
overlaps <- seq(0.25, 1.00, by = 0.05)
)
plot_fft_comparativo(resultado_comp, estado_alvo = "DF", janela_alvo = 2)
resultado_fft$estado$AM
resultado_fft$AM
resultado_fft
View(resultado_fft)
resultado_fft <- fft_janelas_anuais_estados_v2(
dados = rad_limpo,
primeiro_dia = TRUE,
ultimo_dia = TRUE,
overlap_percent = 0.4,
grafico = FALSE
)
resultado_fft
resultado_comp <- comparar_overlaps_fft(
dados = rad_limpo,
overlaps <- seq(0.25, 1.00, by = 0.05)
)
plot_fft_comparativo(resultado_comp, estado_alvo = "DF", janela_alvo = 2)
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# Selecionando apenas as colunas interessantes
rad_limpo <- select(rad_limpo)
# Visualizando séries temporais de radiação
plots_teste <- plotar_series_todos_estados(rad_limpo, "2001-01-01", "ano", FALSE)
#
# fft_teste <- fft_series_todos_estados(rad_limpo,"2001-01-01", periodo = "ano", primeiro_dia = FALSE, grafico = TRUE)
# plots_teste$AM
# fft_teste$AM$plot
# plots_teste$BA
# fft_teste$BA$plot
# plots_teste$DF
# fft_teste$DF$plot
# plots_teste$RJ
# fft_teste$RJ$plot
# plots_teste$RS
# fft_teste$RS$plot
swfft_global <- fft_janelas_anuais_estados(rad_limpo, primeiro_dia = TRUE, ultimo_dia = TRUE, ov = 40)
swfft_global$DF
glimpse(rad_limpo)
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Selecionando apenas as colunas interessantes
rad_limpo <- selector(rad_limpo)
# Visualizando o conjunto de dados
glimpse(rad_limpo)
swfft_global <- fft_janelas_anuais_estados(rad_limpo, primeiro_dia = TRUE, ultimo_dia = TRUE, ov = 40)
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# ---------- CARREGAR FUNÇÕES E PACOTES ----------
source("funcoes_SWFFT.R")
# Visualizando o conjunto de dados
glimpse(rad_limpo)
# Selecionando apenas as colunas interessantes
rad_limpo <- selector(rad_limpo)
swfft_global <- fft_janelas_anuais_estados(rad_limpo, primeiro_dia = TRUE, ultimo_dia = TRUE, ov = 40)
swfft_global$DF
